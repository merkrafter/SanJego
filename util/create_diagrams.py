import argparse
from typing import Any, Callable

import scipy.sparse
from experiments_adapter import ExperimentsAdapter


def create_matrix(results_dir: str, _filter: Callable) -> Any:
    """
    Returns a 2-dimensional numpy array that summarizes the results from the experiments that satisfy `_filter`.
    :param results_dir: the experiment result's directory
    :param _filter: condition that experiments must satisfy to be recognized in this matrix
    :return: numpy array
    """
    ea = ExperimentsAdapter(results_dir)
    experiments = filter(_filter, ea)

    # determine the max height and width
    max_height = -1
    max_width = -1
    for experiment in experiments:
        if experiment['config']['height'] > max_height:
            max_height = experiment['config']['height']
        if experiment['config']['width'] > max_width:
            max_width = experiment['config']['width']
    A = scipy.sparse.lil_matrix((max_height, max_width))

    ea.reload()
    experiments = filter(_filter, ea)
    for experiment in experiments:
        height = experiment['config']['height']
        width = experiment['config']['width']
        result = experiment['run']['result']
        A[height - 1, width - 1] = result  # height, width are 1-indexed

    return A.toarray().astype(int)


def create_value_matrix_max_first(results_dir: str, rules: str) -> Any:
    """
    Returns a 2-dimensional numpy array that summarizes the results from the experiments with `rules` and the
    maximizing player starting.
    :param results_dir: the experiment result's directory
    :param rules: the rule set to evaluate
    :return: numpy array
    """
    return create_matrix(results_dir, lambda x: x['config']['rules'] == rules and x['config']['max_player_starts'])


def create_value_matrix_min_first(results_dir: str, rules: str) -> Any:
    """
    Returns a 2-dimensional numpy array that summarizes the results from the experiments with `rules` and the
    minimizing player starting.
    :param results_dir: the experiment result's directory
    :param rules: the rule set to evaluate
    :return: numpy array
    """
    # TODO fill with the values from the "max starting" experiments
    return create_matrix(results_dir, lambda x: x['config']['rules'] == rules and not x['config']['max_player_starts'])


def to_latex_table(matrix) -> str:
    """
    Creates a string containing LaTeX code that displays a table with the matrix data.
    :param matrix: the data to display. is expected to be an upper triangular matrix
    :return: LaTeX code to display a table
    """
    height, width = matrix.shape
    latex_code = "% generated by python script\n"
    column_specifier = "c" * (width + 1) + "}\n"
    column_specifier = column_specifier[0] + "|" + column_specifier[1:]  # insert vertical line
    latex_code += r"\begin{tabular}{" + column_specifier  # table definition
    latex_code += "  &" + "& ".join([str(i) for i in range(1, width + 1)]) + r"\\" + "\n"  # table head
    latex_code += r"  \midrule" + "\n"  # midrule

    # actual table content
    for row in range(height):
        latex_code += f"  {row + 1} & "
        values = [str(val) for val in matrix[row, :]]
        values[:row] = [' '] * row
        latex_code += "& ".join(values)
        latex_code += r"\\" + "\n"

    latex_code += r"\end{tabular}"  # end of table
    return latex_code


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("RULESET")
    parser.add_argument("RESULT_DIR")
    parser.add_argument("--min-first", action="store_true")
    namespace = parser.parse_args()
    rules = namespace.RULESET
    result_dir = namespace.RESULT_DIR
    if not namespace.min_first:
        matrix = create_value_matrix_max_first(results_dir=result_dir, rules=rules)
    else:
        matrix = create_value_matrix_min_first(results_dir=result_dir, rules=rules)
    print(to_latex_table(matrix))
